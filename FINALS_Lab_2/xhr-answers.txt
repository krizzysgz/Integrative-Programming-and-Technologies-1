1. What is the difference between readyState and status in XMLHttpRequest?
Answer: The readyState property shows the current stage of the XMLHttpRequest, 
indicating how far the request has progressed — from being created up to finishing 
the process. Meanwhile, the status property is a read-only value that provides the 
numeric HTTP status code sent back by the server, showing the server’s response 
after handling the request.

2. How can you make the request asynchronous?
Answer: There are three common ways to make 
asynchronous requests in JavaScript:

- XMLHttpRequest (XHR)
This is the earliest method used for sending asynchronous requests. 
XHR allows you to communicate with a server and retrieve data without 
refreshing the entire webpage.

Example:
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/1', true);
xhr.onload = function () {
    if (this.status === 200) {
        console.log(JSON.parse(this.responseText));
    } else {
        console.error('Error');
    }
};
xhr.send();

- Promises
A Promise represents the result of an asynchronous 
operation—either it succeeds or fails. It helps make 
async code easier to read and manage by using .then() for 
handling success and .catch() for errors.

Example:
fetch('https://jsonplaceholder.typicode.com/todos/1')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error(error));


- Async/Await
Async/await is a more modern and cleaner way to work with 
asynchronous code. It is built on top of Promises but lets you 
write code that looks more like regular synchronous JavaScript.

Example:
async function getData() {
  try {
    const response = await fetch('https://example.com/api/data');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}
getData();


3. Why is asynchronous communication recommended for web applications?
Answer: Asynchronous communication is preferred in web applications 
because it boosts efficiency, scalability, and overall responsiveness 
by eliminating the need for instant, blocking responses. It lets the 
browser remain interactive even while data is being fetched, 
preventing freezes and allowing smooth updates such as loading 
indicators or partial content rendering.
